问题描述
	输入表达式字符串，以“=”表示结束，计算并输出表达式值。操作数可以是整数或实数，操作符有“+”、“-”、“*”、“/”、“^”和“sin()”、“cos()”、“log()”、“ln()”等函数。
算法思路
	运用两个栈，其中一个栈存
算法描述
    该计算器的运行基于下端的两个模块：负责读取数据的输入模块'getIn'和进行数学实现的运算模块'reverse'。而两者的运行都依赖于'myStack'中与栈相关的底层基本操作函数。
    getIn:
    程序开始运行时，主读取函数将申请空间创建一个数组'Array'用于读取输入数据，并同步创建一个存储前括号'('的首节点以在后期递归的实现过程中提供高效的便利性。对数组及元素计数器进行初始化后，程序从键盘读取数据进入字符串'inputStr'，遇到'='符号时结束读取。出于程序健壮性的考虑，计算器在没有读入等于符号时会对用户进行提示并要求正确输入。
    创建一个data类型的新节点'now'代表当前从字符串inputStr读取的元素，记录其占用的字符空间并开始读入。值得一提的是，当读取的为数字时，我们使用的算法可以与C库中的Atof函数配合达到无论是普通数字、小数或是科学计数法都能成功返回的效果。对字符的判别部分采用了四个字符数组，分别存储计算器可能会使用到的单目操作符、括号、函数名和特殊常数（如π、e等等）作为样本以便判断输入。这种方式在增强代码可读性的同时拥有极高的可拓展性，当用户有计算其他函数及特殊常数的需求时，只需要在函数计算部分及常数的定义部分额外定义并增加宏的数值即可。
    成功读取元素后判断数据类型：若读取到了占用空间为0的数据将会进行提示；若读取到'='则创建尾节点；读取到操作数和操作符都将写入Array。流程结束后将再次循环，直到读入'='停止写入，返回Array。
    同时，该部分模块还具备了满足用户不同输出需求的“个性化”输出设置，（*此处可以描述具体实现过程凑字数/待补充*）使用只需键入mod调出设置面板。
    reverse:
    将getIn处理后的串导入，同时扫描元素并赋予它们各自的运算优先级，紧接着进行递归结构的初始化。调用栈的基本操作函数创建两个栈：操作符栈（oprStack）和操作数栈（opdStack）且予后者赋值为0的头节点。此时数学实现过程的基础架构搭建完毕，进入运算循环阶段：若扫描到操作数，将其压入操作数栈；若扫描到操作符，在操作符栈已经为空、栈顶元素为左括号或者为低于该操作符优先级的符号的情况时直接压入栈，若栈顶元素的优先级比它更高，则从栈顶开始根据其单目双目类型与操作数栈同步弹出，进入运算循环直到操作符栈顶的元素优先级不再高于当前扫描的元素，将其压入栈内；若扫描到括号元素则进入递归准备流程：在元素为左括号的情况下，递归次数计数器数值+1而后引用运算模块reverse本身进入递归以求解括号内的值，为所得值创建节点压入栈中，继续进行后续运算。若元素为右括号，括号待配平计数器数值-1并从栈顶开始运算括号内的值，直到再次遇到左括号结束运算，将两个括号弹出后继续进行后续运算；若扫描到等于符号，对栈内剩余的简单表达式进行最终运算并弹出数值。运算结束之后，由源程序接入数值并打印到屏幕上。
    由于该程序内结构模块化性强，具有低耦合的特性，因此在后续对程序进行调试时的可调试性十分优秀，可以迅速定位异常代码位置以节约编写者调试时间；同时程序单次操作为一次性流程，且巧妙地运用了递归，因此大大减少了编码负重并且展现了极高的可读性。编者在编码初期曾尝试过以联合存储元素，但发现联合无法简单判断字符和数字类型，而结构体可以轻松地解决了这个问题，成为了该计算器内部存储形式的不二之选。
    myStack:
    作为两个下端模块运行的必要基础，myStack函数的调用基本渗透了程序工作流程的全程。其中创建节点的函数'makeNode'在输入模块和运算模块中均占有不可或缺的地位，而创建栈函数'createStack'、查看弹出函数'topAndPop'和添加元素函数'push'在运算模块对栈的操作中也有多次引用。
源程序及驱动程序
    
测试数据

结果分析和结论
    调试数据与测试数据均正确，计算器运行成功。
心得体会
    （*编码同学心得体会/待补充*）
    （*测试同学心得体会/待补充*）
    对于撰写文档的同学，工作主要是对编码工程进行概念的整合并用语言表述出它们的内在逻辑和闪光点。而对于本次上机实验庞大的代码量，要单人理解还是有不少的困难。而这时团队协作的优点就显现了出来：负责编码的同学能在为负责文档的同学理清代码思路与逻辑的同时，文档同学能结合自己的理解为代码附上易懂的注释，这样不仅能达到使团队共同理解工程内部结构的目的，更节省了编写代码同学标记注释的时间并能迸发出优化一些细节代码的更佳算法思路，做到“分而治之”1+1+1>3的高效率工程模式。而在编写文档的同时，该同学也充分地提高了自己对代码的认知能力，在之后的工作中也能借鉴这次作业中其他同学不同的思路进行算法的设计。作为工程的最后一项也是总结工程的任务，我们也发现团队的良好和即时的交流对于最后文档的编写环节至关重要，所以交流环节的进行在工程任务流程中开始的越早，工作完成效率的提高会更加显著。
    （*总体感受：了解计算器运行原理blabla之类的/待补充*）
分工及签名
    编码：王喆
    测试：韦晗潇
    文档：梁家瑞