## 问题描述
	输入表达式字符串，以“=”表示结束，计算并输出表达式值。操作数可以是整数或实数，操作符有“+”、“-”、“*”、“/” “%”、“^”和“sin()”、“cos()”、“lg()”、“ln()”等函数。
## 算法思路
	运用两个栈，其中一个栈存储操作数，另一个找，存储操作符。读入并处理完字符串后，遍历产生的结构体数组，根据读到的结构体变量的的flag，判断结构体变量的类型，若为数字，则压入操作数栈中，若为操作符，则根据操作符的类型，进行分流，括号就进入专门处理括号的函数，二元运算符就进入处理二元运算符的函数，一元运算符就进入处理一元运算符的函数。等于号也进入专有函数。对于括号，若为左括号，则开始求左括号包围的表达式的值，若为二元运算符，则首先判断读到的二元运算符的优先级，与栈顶元素的优先级的关系，若栈顶元素优先级低，则把读到的二元运算符入栈，若优先级高，则弹出运算符，弹出操作数栈的两个元素，进行计算后，把结果压入操作数栈中，并重复这一过程，直到发现优先级比读到的二元运算符更低的元素，才停止。之后再把读到的二元运算符入栈。若为一元运算符，则我们先把运算符入操作符栈，然后计算出运算符后面的括号内的值，然后在弹出一元运算符的时候求值。我们把每一次表达式求值都抽象为求一组括号内的表达式的值，并以此为依据编码，达到了可以通过递归轻易处理sin(2*(-3))的效果。
## 算法描述
    该计算器的运行基于下端的两个模块：负责读取数据的输入模块'getIn'和进行数学实现的运算模块'reverse'。而两者的运行都依赖于'myStack'中与栈相关的底层基本操作函数。
    getIn:
    程序开始运行时，主读取函数将申请空间创建一个数组'Array'用于读取输入数据，并同步创建一个存储前括号'('的首节点以在后期递归的实现过程中提供高效的便利性。对数组及元素计数器进行初始化后，程序从键盘读取数据进入字符串'inputStr'，遇到'='符号时结束读取。出于程序健壮性的考虑，计算器在没有读入等于符号时会对用户进行提示并要求正确输入。
    创建一个data类型的新节点'now'代表当前从字符串inputStr读取的元素，记录其占用的字符空间并开始读入。值得一提的是，当读取的为数字时，我们使用的算法可以与C库中的Atof函数配合达到无论是普通数字、小数或是科学计数法都能成功返回的效果。对字符的判别部分采用了四个字符数组，分别存储计算器可能会使用到的单目操作符、括号、函数名和特殊常数（如π、e等等）作为样本以便判断输入。这种方式在增强代码可读性的同时拥有极高的可拓展性，当用户有计算其他函数及特殊常数的需求时，只需要在函数计算部分及常数的定义部分额外定义并增加宏的数值即可。
    成功读取元素后判断数据类型：若读取到了占用空间为0的数据将会进行提示；若读取到'='则创建尾节点；读取到操作数和操作符都将写入Array。流程结束后将再次循环，直到读入'='停止写入，返回Array。
    同时，该部分模块还具备了满足用户不同输出需求的“个性化”输出设置，（*此处可以描述具体实现过程凑字数/待补充*）使用只需键入mod调出设置面板。
    reverse:
    将getIn处理后的串导入，同时扫描元素并赋予它们各自的运算优先级，紧接着进行递归结构的初始化。调用栈的基本操作函数创建两个栈：操作符栈（oprStack）和操作数栈（opdStack）且予后者赋值为0的头节点。此时数学实现过程的基础架构搭建完毕，进入运算循环阶段：若扫描到操作数，将其压入操作数栈；若扫描到操作符，在操作符栈已经为空、栈顶元素为左括号或者为低于该操作符优先级的符号的情况时直接压入栈，若栈顶元素的优先级比它更高，则从栈顶开始根据其单目双目类型与操作数栈同步弹出，进入运算循环直到操作符栈顶的元素优先级不再高于当前扫描的元素，将其压入栈内；若扫描到括号元素则进入递归准备流程：在元素为左括号的情况下，递归次数计数器数值+1而后引用运算模块reverse本身进入递归以求解括号内的值，为所得值创建节点压入栈中，继续进行后续运算。若元素为右括号，括号待配平计数器数值-1并从栈顶开始运算括号内的值，直到再次遇到左括号结束运算，将两个括号弹出后继续进行后续运算；若扫描到等于符号，对栈内剩余的简单表达式进行最终运算并弹出数值。运算结束之后，由源程序接入数值并打印到屏幕上。
    由于该程序内结构模块化性强，具有低耦合的特性，因此在后续对程序进行调试时的可调试性十分优秀，可以迅速定位异常代码位置以节约编写者调试时间；同时程序单次操作为一次性流程，且巧妙地运用了递归，因此大大减少了编码负重并且展现了极高的可读性。编者在编码初期曾尝试过以联合存储元素，但发现联合无法简单判断字符和数字类型，而结构体可以轻松地解决了这个问题，成为了该计算器内部存储形式的不二之选。
    myStack:
    作为两个下端模块运行的必要基础，myStack函数的调用基本渗透了程序工作流程的全程。其中创建节点的函数'makeNode'在输入模块和运算模块中均占有不可或缺的地位，而创建栈函数'createStack'、查看弹出函数'topAndPop'和添加元素函数'push'在运算模块对栈的操作中也有多次引用。
源程序及驱动程序
    
## 测试数据

## 结果分析和结论
    调试数据与测试数据均正确，计算器运行成功。
## 心得体会
    在编码工作中，我首先意识到的就是选择变量类型的时候，要谨慎且全面的考虑，比如我最开始选择了联合来储存一个栈元素，只考虑了联合带来的内存开销的减少，但是却忽略了难以通过联合的内容判断数据的内容是数字还是操作符，因此匆匆忙忙的改为了结构体，但是通过结构体实现了完了之后，才发现其实可以采用结构体套联合的方法来结局变量问题的判断。其次我意识到了良好的有自解释性的命名的好处，同时，对于部分难懂的函数，写好注释，不仅方便自己debug，也方便阅读代码的人理解内容。同时，在写代码前，除非十分有信心，应该先用伪码描述一下自己要干的事情，然后抽象出对应的函数，先写出大体的框架，再实现各个函数的细节部分，如此则可以将整个编码的过程，变得十分有条理和模块化。当某一部分代码重复之后，就应该考虑抽象成函数。
    我还体会到了模块化的好处，除了能够把编码工作细化以外，当确定了某个函数没有问题之后，在后续debug的过程中，可以直接跳过这个函数，这样就大大减少了debug的工作量。同时熟练的使用Github，使得小组之间合作更为方便，大家随时可以登录网站，查看小组的代码开发到了什么地步，随时随地的添加注释等。同时我们发现，中文会出现编码的问题，所以我们决定使用英文进行输入和输出的提示。
    （*测试同学心得体会/待补充*）
    对于撰写文档的同学，工作主要是对编码工程进行概念的整合并用语言表述出它们的内在逻辑和闪光点。而对于本次上机实验庞大的代码量，要单人理解还是有不少的困难。而这时团队协作的优点就显现了出来：负责编码的同学能在为负责文档的同学理清代码思路与逻辑的同时，文档同学能结合自己的理解为代码附上易懂的注释，这样不仅能达到使团队共同理解工程内部结构的目的，更节省了编写代码同学标记注释的时间并能迸发出优化一些细节代码的更佳算法思路，做到“分而治之”1+1+1>3的高效率工程模式。而在编写文档的同时，该同学也充分地提高了自己对代码的认知能力，在之后的工作中也能借鉴这次作业中其他同学不同的思路进行算法的设计。作为工程的最后一项也是总结工程的任务，我们也发现团队的良好和即时的交流对于最后文档的编写环节至关重要，所以交流环节的进行在工程任务流程中开始的越早，工作完成效率的提高会更加显著。
    （*总体感受：了解计算器运行原理blabla之类的/待补充*）
